<html>
  <head>
    <meta charset="utf-8"/>
  </head>
  <body>
    <head><title>Seymour-Lib</title></head>
    <script src="node_modules/checked-emitter/dist/checked-emitter.js"></script>
    <script src="node_modules/codemirror/lib/codemirror.js"></script>

    <!-- <script src="js/SourceLoc.js"></script> -->

    <script src="python-in-ohm/SourceLoc.js"></script>
    <script src="python-in-ohm/node_modules/ohm-js/dist/ohm.js"></script>
    <script src="python-in-ohm/node_modules/underscore/underscore-min.js"></script>
    <script src="python-in-ohm/node_modules/lex/lexer.js"></script>
    <script src="python-in-ohm/utils.js"></script>
    <script src="python-in-ohm/SourceMap.js"></script>
    <script src="python-in-ohm/lexer/tokens.js"></script>
    <script src="python-in-ohm/lexer/index.js"></script>
    <script src="python-in-ohm/parser/grammar.js"></script>
    <script src="python-in-ohm/parser/semantics.js"></script>
    <script src="python-in-ohm/parser/ast.js"></script>
    <script src="python-in-ohm/parser/instrumented.js"></script>
    <script src="python-in-ohm/parser/sourceLoc.js"></script>
    <script src="python-in-ohm/parser/toAST.js"></script>
    <script src="python-in-ohm/parser/easyAst.js"></script>
    <script src="python-in-ohm/parser/toList.js"></script>
    <script src="python-in-ohm/parser/verify.js"></script>
    <script src="python-in-ohm/parser/index.js"></script>

    <script src="js/pathmatcher.js"></script>
    <script src="js/Env.js"></script>
    <script src="js/EventRecorder.js"></script>
    <script src="js/MicroVizEvents.js"></script>
    <script src="js/events.js"></script>
    <script src="js/lib.js"></script>
    <script src="js/macroViz.js"></script>
    <script src="js/microViz.js"></script>
    <script src="js/prog.js"></script>
    <script src="js/renderModel.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css" >
    <link rel="stylesheet" type="text/css" href="node_modules/codemirror/lib/codemirror.css"></script>
    <link rel="stylesheet" type="text/css" href="macroViz.css"></script>
    <link rel="stylesheet" type="text/css" href="microViz.css"></script>
    <link rel="stylesheet" type="text/css" href="highlighting.css"></script>
    <div id="exampleButtons"></div>
    <div id="microVizDivContainer">
      <!-- <div id="microVizDiv"></div> -->
    </div>
    <div id="macroVizDivContainer">
      <!-- <div id="macroVizDiv"></div> -->
    </div>
    <script>

/**
 * TODO:
 * click to focus
 * don't count enternewscope as a send in the macroviz
*/

window.macroViz = new MacroViz(macroVizDivContainer);
window.microViz = new MicroViz(microVizDivContainer, true);
window.cm = microViz.editor;
cm.setOption('lineNumbers', true);
cm.setOption('readOnly', true);
cm.setOption('viewportMargin', Infinity);

macroViz.addListener('click', (__, event, _) => {
  let pathMatchers = getPathMatchers(event.activationEnv);
  
  macroViz.events.forEach(event => macroVizClear(event, 'focus', false));

  microViz.setPaths(pathMatchers);
  pathMatchers.forEach(path => { 
    macroVizHighlight(path.env.programOrSendEvent, 'focus', '');
    this.microViz.addImplementation(path.env.microVizEvents);
  });
})

function macroVizClear(event, highlightType = null, isPrefix = false) {
  const view = macroViz.getNodeView(event);
  if (!view) return;
  if (highlightType !== null && !isPrefix) {
    view.DOM.classList.remove(`highlight-${highlightType}`);
  } else {
    const prefix = highlightType === null ? '' : highlightType;
    const classList = view.DOM.classList;
    for (let i = classList.length - 1; i >= 0; i--) {
      const cls = classList[i];
      if (cls.startsWith(`highlight-${prefix}`)) {
        classList.remove(cls)
      }
    }
  }
}

function macroVizHighlight(event, highlightType) {
  const view = macroViz.getNodeView(event);
  if (!view) return;
  view.DOM.classList.add(`highlight-${highlightType}`);
}


const examples = {};

function addExample(name, setupFn) {
  const button = exampleButtons.appendChild(document.createElement('a'));
  button.classList.add('exampleButton');
  button.appendChild(document.createTextNode(name));
  button.setAttribute('href', '?' + name);
  examples[name] = () => {
    button.classList.add('selected');
    setupFn();
  };
}

let globalEnv;

const envs = {};
const events = {};
const eventArgOrders = {
  ProgramEvent: ['orderNum', 'sourceLoc'],
  SendEvent: ['orderNum', 'sourceLoc', 'envId', 'recv', 'selector', 'args'],
  VarDeclEvent: ['orderNum', 'sourceLoc', 'envId', 'declEnvId', 'name', 'value'],
  VarAssignmentEvent: ['orderNum', 'sourceLoc', 'envId', 'declEnvId', 'name', 'value'],
  InstVarAssignmentEvent: ['orderNum', 'sourceLoc', 'envId', 'obj', 'name', 'value'],
  InstantiationEvent: ['orderNum', 'sourceLoc', 'envId', 'class', 'args', 'newInstance'],
  ReceiveEvent: ['envId', 'returnValue'],
  LocalReturnEvent: ['orderNum', 'sourceLoc', 'envId', 'value'],
  ErrorEvent: ['sourceLoc', 'envId', 'errorString']
};
const eventMethods = {
  ProgramEvent: 'program',
  SendEvent: 'send',
  VarDeclEvent: 'declVar',
  VarAssignmentEvent: 'assignVar',
  InstVarAssignmentEvent: 'assignInstVar',
  InstantiationEvent: 'instantiate',
  ReceiveEvent: 'receive',
  LocalReturnEvent: 'localReturn',
  ErrorEvent: 'error'
};
const typeToClass = {
  Env,
  Scope
}

function makeSourceLoc(json) {
  if (json === null) {
    return null;
  }
  return new SourceLoc(
    json.startIdx,
    json.endIdx,
    // json.startPos,
    // json.endPos,
    // json.startLineNumber,
    // json.endLineNumber,
    // json.name
  )
}

function fixupEnv(envJSON) {
  const env = new typeToClass[envJSON.type](
    makeSourceLoc(envJSON.sourceLoc),
    envs[envJSON.parentEnvId],
    envs[envJSON.callerEnvId],
    events[envJSON.programOrSendEventId]
  );
  if (env.programOrSendEvent instanceof ProgramEvent) {
    globalEnv = env;
    env.programOrSendEvent.activationEnv = env;
  }
  return env;
}

function fixupEvent(R, eventJSON) {
  const args = [];
  eventArgOrders[eventJSON.type].forEach(key => {
    if (key.includes('Env') || key.includes('env')) {
      args.push(envs[eventJSON[key]]);
    } else if (key === 'sourceLoc') {
      args.push(makeSourceLoc(eventJSON.sourceLoc))
    } else {
      args.push(eventJSON[key]);
    }
  });
  R[eventMethods[eventJSON.type]](...args);
  R.lastEvent.id = eventJSON.id;
  events[R.lastEvent.id] = R.lastEvent;
}

function onMessage(R) {
  return (e) => {
    const data = JSON.parse(e.data); 
    console.log(data); 
    switch(data.type) {
      case 'Env':
      case 'Scope':
        envs[data.id] = fixupEnv(data);
        R._registerSend(envs[data.id])
        if (envs[data.id].callerEnv == null) {
          microViz.setPaths([new PathMatcher([], envs[data.id])]);
          microViz.addImplementation(envs[data.id].microVizEvents);
        }
        break;
      case 'done':
        break;
      default:
        fixupEvent(R, data)
    }
  };
}

function onOpen(socket, sls, instrumentedCode) {
  return () => {
    socket.send(JSON.stringify({ type: 'kill' }))
    socket.send(JSON.stringify({
      type: 'run',
      sourceLocs: sls, 
      code: instrumentedCode
    }));
  }
}

addExample('python-fib', () => {
  prog({name: 'program', code: [
    {name: 'fibDef', code: ['def fib(', {name: 'nDecl', code: 'n'}, '):\n',
    '  if n < 2:\n',
    '    ', {name: 'baseReturn', code: 'return n'}, '\n',
    '  else:\n',
    '    ', {name: 'faDecl', code: ['fa = ', {name: 'faCall', code: 'fib(n-1)'}]}, '\n',
    '    ', {name: 'fbDecl', code: ['fb = ', {name: 'fbCall', code: 'fib(n-2)'}]}, '\n',
    '    ', {name: 'recReturn', code: 'return fa + fb'}, '\n',
    ]},
    '\n\n',
    {name: 'theLoop', code: [
    'for ', {name: 'xDecl', code: 'x'}, ' in ', {name: 'range', code: 'range(5)'}, ': \n',
    '  ', {name: 'fxDecl', code: ['fx = ', {name: 'fibCall', code: 'fib(x)'}]}, 
    ]}, '\n'
  ]});

// const instrumentedCode = `
// def runCode():
//   globalEnv = R.program(1, sls['program'])
  
//   def fib(n):
//     fEnv = R.mkEnv(sls['fibDef'], globalEnv, fib, '__call__', [n])
//     R.assignVar(1, sls['nDecl'], fEnv, fEnv, 'n', n)
//     if n < 2: 
//       return R.localReturn(2, sls['baseReturn'], fEnv, n)
//     else:
//       fa = R.assignVar(4, sls['faDecl'], fEnv, fEnv, 'fa', 
//         (R.send(3, sls['faCall'] , fEnv, fib, '__call__', [n-1], None), R.receive(fEnv, fib(n-1)))[1])
//       fb = R.assignVar(6, sls['fbDecl'], fEnv, fEnv, 'fb', 
//         (R.send(5, sls['fbCall'], fEnv, fib, '__call__', [n-2], None), R.receive(fEnv, fib(n-2)))[1])
//       return R.localReturn(7, sls['recReturn'], fEnv, fa + fb)

//   theRange = (
//     R.send(2, sls['range'], globalEnv, range, '__call__', [5], None), 
//     R.receive(globalEnv, range(5))
//   )[1]
//   loopEnv = R.enterScope(3, sls['theLoop'], globalEnv)
//   for x in theRange:
//     R.assignVar(4, sls['xDecl'], loopEnv, globalEnv, 'x', x)
//     fx = R.assignVar(6, sls['fxDecl'], loopEnv, globalEnv, 'fx', 
//       (R.send(5, sls['fibCall'], loopEnv, fib, '__call__', [x], None), R.receive(loopEnv, fib(x)))[1])
//   R.leaveScope(loopEnv)
  
//   R.done()
// `;

  let code = lines.join('\n');
  SourceLoc.setupCodeMap(code);
  const preprocessor = new Preprocessor();
  const instrumenter = new Instrumenter();
  ({code, map} = preprocessor.preprocess(code));
  const instrumentedCode = instrumenter.instrument(code, map);
  console.debug(instrumentedCode);

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('python-for', () => {
  prog({name: 'program', code: [
    {name: 'sumDecl', code: 'sum = 0'}, '\n', {name: 'theLoop', code: [
    'for ',
      {name: 'xDecl', code: 'x'},
      ' in ',
      {name: 'range', code: 'range(5)'}, ': \n',
    '  ', {name: 'sumAssignment', code: 'sum = sum + x'}
    ]}, '\n'
  ]});

  //   const instrumentedCode = `
  // def runCode():
  //   globalEnv = R.program(1, sls['program'])
  
  //   sum = R.assignVar(2, sls['sumDecl'], globalEnv, globalEnv, 'sum', 0)
  
  //   theRange = (
  //     R.send(3, sls['range'], globalEnv, range, '__call__', [5], None), 
  //     R.receive(globalEnv, range(5))
  //   )[1]
  //   loopEnv = R.enterScope(4, sls['theLoop'], globalEnv)
  //   for x in theRange:
  //     R.assignVar(5, sls['xDecl'], loopEnv, globalEnv, 'x', x)
  //     sum = R.assignVar(6, sls['sumAssignment'], loopEnv, globalEnv, 'sum', sum + x)
  //   R.leaveScope(loopEnv)
  
  //   R.done()
  // `;

  let code = lines.join('\n');
  SourceLoc.setupCodeMap(code);
  const preprocessor = new Preprocessor();
  const instrumenter = new Instrumenter();
  ({code, map} = preprocessor.preprocess(code));
  const instrumentedCode = instrumenter.instrument(code, map);
  console.debug(instrumentedCode);


  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('python-reduce', () => {
  prog({name: 'program', code: [
    {name: 'import', code: 'from functools import reduce'}, '\n\n',
    {name: 'ansDecl', code: ['ans = ',
      {name: 'reduce', code: ['reduce(\n',
      '  ', {name: 'lambda', code: [
        'lambda ', {name: 'xDecl', code: 'x'}, ', ' , {name: 'yDecl', code: 'y'}, ':\n',
      '    ', {name: 'plus', code: 'x + y'}]}, ',\n',
      '  [1, 2, 3, 4], 0)'
      ]}
    ]}, '\n'
  ]});

//   const instrumentedCode = `
// from functools import reduce

// def runCode():
//   globalEnv = R.program(1, sls['program'])

//   def _lambda1(x, y):
//     lEnv = R.mkEnv(sls['lambda'], globalEnv, _lambda1, '__call__', [x, y])
//     R.assignVar(1, sls['xDecl'], lEnv, lEnv, 'x', x)
//     R.assignVar(2, sls['yDecl'], lEnv, lEnv, 'y', y)
//     return R.localReturn(3, sls['plus'], lEnv, x + y)

//   ans = R.assignVar(3, sls['ansDecl'], globalEnv, globalEnv, 'ans', 
//     (
//       R.send(2, sls['reduce'], globalEnv, reduce, '__call__', [_lambda1, [1, 2, 3, 4], 0], None),
//       R.receive(globalEnv, reduce(_lambda1, [1, 2, 3, 4], 0))
//     )[1]
//   )

//   R.done()
// `;

  let code = lines.join('\n');
  SourceLoc.setupCodeMap(code);
  const preprocessor = new Preprocessor();
  const instrumenter = new Instrumenter();
  ({code, map} = preprocessor.preprocess(code));
  const instrumentedCode = instrumenter.instrument(code, map);
  console.debug(instrumentedCode);

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('python-raise', () => {
  prog({name: 'program', code: [
    {name: 'raise', code: 'raise Exception("hi")'}]
  });

  const instrumentedCode = `
def runCode():
  globalEnv = R.program(1, sls['program'])
  exc = Exception("hi")
  raise R.error(sls['raise'], globalEnv, Exception("hi"))
  R.done()
`;

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('python-less', () => {
  prog({name: 'program', code: [
    {name: 'lessDef', 
      code: ['def less(', {name: 'argDecl', code: 'a'},', ', {name: 'bDecl', code: 'b'}, '):\n',
      '  ', {name: 'return', code: 'return a < b'}
    ]}, '\n\n',
    {name: 'fiveDef', 
      code: ['def five():\n',
      '  ', {name: 'return5', code: 'return 5'}
    ]}, '\n\n',
    {name: 'aDecl', code: ['a = ', 
      {name: 'ifThenElse', code: [{name: 'fiveCall', code: 'five()'}, ' if ', {name: 'lessCall', code: 'less(3, 5)'}, ' else 2']  }
  ]}]});

//   const instrumentedCode = `
// def runCode():
//   globalEnv = R.program(1, sls['program'])

//   def less(a, b):
//     fEnv = R.mkEnv(sls['lessDef'], globalEnv, less, '__call__', [a, b])
//     R.assignVar(1, sls['argDecl'], fEnv, fEnv, 'a', a)
//     R.assignVar(2, sls['bDecl'], fEnv, fEnv, 'b', b)
//     return R.localReturn(3, sls['return'], fEnv, a < b)
  
//   def five():
//     fEnv = R.mkEnv(sls['fiveDef'], globalEnv, five, '__call__', [])
//     return R.localReturn(1, sls['return5'], fEnv, 5)
  
//   a = R.assignVar(4, sls['aDecl'], globalEnv, globalEnv, 'a', 
//     (R.send(3, sls['fiveCall'], globalEnv, five, '__call__', [], None), R.receive(globalEnv, five()))[1] if 
//       (R.send(2, sls['lessCall'], globalEnv, less, '__call__', [5, 3], None), R.receive(globalEnv, less(3, 5)))[1] else 
//       2)
//   R.done()
// `;

  let code = lines.join('\n');
  SourceLoc.setupCodeMap(code);
  const preprocessor = new Preprocessor();
  const instrumenter = new Instrumenter();
  ({code, map} = preprocessor.preprocess(code));
  const instrumentedCode = instrumenter.instrument(code, map);
  console.debug(instrumentedCode);


  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('python-point', () => {
  prog({name: 'program', code: [
    {name: 'pointDef', code: ['class Point(object):\n',
      {name: 'initDef', code: ['  def __init__(',
        {name: 'selfDecl1', code: 'self'}, ', ', {name: 'xDecl1', code: 'x'}, ', ', {name: 'yDecl1', code: 'y'}, '):\n',
        {name: 'instXDecl', code: '    self.x = x'}, '\n',
        {name: 'instYDecl', code: '    self.y = y'}]}, '\n\n',
      {name: 'strDef', code: ['  def __str__(',
        {name: 'selfDecl2', code: 'self'}, '):\n',
        {name: 'sxDecl', code: ['    sx = ', {name: 'strCallX', code: 'str(self.x)'}]}, '\n',
        {name: 'syDecl', code: ['    sy = ', {name: 'strCallY', code: 'str(self.y)'}]}, '\n',
        {name: 'strReturn', code: '    return "(" + sx + ", " + sy + ")"'}]}, '\n\n',
      {name: 'toDebugStringDef', code: ['  def toDebugString(',
        {name: 'selfDecl3', code: 'self'}, '):\n',
        {name: 'debugReturn', code: ['    return ', {name: 'strCallDebug', code: 'str(self)'}]}]}, '\n\n',
      {name: 'moveDef', code: ['  def move(',
        {name: 'selfDecl4', code: 'self'}, '):\n',
        {name: 'selfXChange', code: '    self.x = self.x + 5'}, '\n',
        {name: 'selfYChange', code: '    self.y = self.y - 7'}]}]}, '\n\n',
    {name: 'pDecl', code: ['p = ', {name: 'PointCall', code: 'Point(1, 2)'}]}, '\n',
    {name: 'sDecl', code: ['s = ', {name: 'strCallGlobal', code: 'str(p)'}]}, '\n\n',
    {name: 'beforeDecl', code: 'before = p'}, '\n',
    {name: 'moveCall', code: 'p.move()'}, '\n',
    {name: 'afterDecl', code: 'after = p'}, '\n']})
    
// const instrumentedCode = `
// def runCode():
//   globalEnv = R.program(1, sls['program'])

//   _env = R.enterScope(2, sls['pointDef'], globalEnv)
//   class Point(object): 
//     def __new__(typ, *args, **kwargs): ## TODO: this should actually look like an fn
//       obj = object.__new__(typ)
//       programOrSendEvent = R.currentProgramOrSendEvent
//       R.instantiate(programOrSendEvent.orderNum, programOrSendEvent.sourceLoc, programOrSendEvent.env, Point, args, obj)
//       return obj

//     def __init__(self, x, y):
//       initEnv = R.mkEnv(sls['initDef'],  _env, self, '__init__', [x, y])
//       R.assignVar(1, sls['selfDecl1'], initEnv, initEnv, 'self', self)
//       R.assignVar(2, sls['xDecl1'], initEnv, initEnv, 'x', x)
//       R.assignVar(3, sls['yDecl1'], initEnv, initEnv, 'y', y)
//       self.x = R.assignInstVar(4, sls['instXDecl'], initEnv, self, 'x', x)
//       self.y = R.assignInstVar(5, sls['instYDecl'], initEnv, self, 'y', y)

//     def __str__(self):
//       strEnv = R.mkEnv(sls['strDef'], _env, self, '__str__', [])
//       R.assignVar(1, sls['selfDecl2'], strEnv, strEnv, 'self', self)
//       sx = R.assignVar(3, sls['sxDecl'], strEnv, strEnv, 'sx', (
//         R.send(2, sls['strCallX'], strEnv, str, '__call__', [self.x], None),
//         R.receive(strEnv, str(self.x))
//       )[1])
//       sy = R.assignVar(5, sls['syDecl'], strEnv, strEnv, 'sy', (
//         R.send(4, sls['strCallY'], strEnv, str, '__call__', [self.y], None),
//         R.receive(strEnv, str(self.y))
//       )[1])
//       return R.localReturn(6, sls['strReturn'], strEnv, "(" + sx + ", " + sy + ")")

//     def toDebugString(self):
//       tdsEnv = R.mkEnv(sls['toDebugStringDef'], _env, self, 'toDebugString', [])
//       R.assignVar(1, sls['selfDecl3'], tdsEnv, tdsEnv, 'self', self)
//       return R.localReturn(4, sls['debugReturn'], tdsEnv, (
//         R.send(2, sls['strCallDebug'], tdsEnv, str, '__call__', [self], None),
//         R.receive(tdsEnv, str(self))
//       )[1])

//     def move(self):
//       moveEnv = R.mkEnv(sls['moveDef'], _env, self, 'move', [])
//       R.assignVar(1, sls['selfDecl4'], moveEnv, moveEnv, 'self', self)
//       self.x = R.assignInstVar(2, sls['selfXChange'], moveEnv, self, 'x', self.x + 5) 
//       self.y = R.assignInstVar(3, sls['selfYChange'], moveEnv, self, 'y', self.y - 7)
//   R.leaveScope(_env)

//   p = R.assignVar(4, sls['pDecl'], globalEnv, globalEnv, 'p', (
//     R.send(3, sls['PointCall'], globalEnv, Point, '__call__', [1, 2], None),
//     R.receive(globalEnv, Point(1, 2))
//   )[1])
//   s = R.assignVar(6, sls['sDecl'], globalEnv, globalEnv, 's', (
//     R.send(5, sls['strCallGlobal'], globalEnv, str, '__call__', [p], None),
//     R.receive(globalEnv, str(p))
//   )[1])

//   before = R.assignVar(7, sls['beforeDecl'], globalEnv, globalEnv, 'before', p)
//   (
//     R.send(8, sls['moveCall'], globalEnv, p, 'move', [], None),
//     R.receive(globalEnv, p.move())
//   )[1]
//   after = R.assignVar(9, sls['afterDecl'], globalEnv, globalEnv, 'after', p)
// `;

  let code = lines.join('\n');
  SourceLoc.setupCodeMap(code);
  const preprocessor = new Preprocessor();
  const instrumenter = new Instrumenter();
  ({code, map} = preprocessor.preprocess(code));
  const instrumentedCode = instrumenter.instrument(code, map);
  console.debug(instrumentedCode);


  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));

  const socket = new WebSocket('ws://localhost:8000');
  socket.addEventListener('message', onMessage(R));
  socket.addEventListener('open', onOpen(socket, sls, instrumentedCode));
});

addExample('seymour-for', () => {
  prog({name: 'program', code: [
    {name: 'forDef', code: [
      'def for ', {name: 'thisDecl', code: 'Number'}, ' ',
        'to: ', {name: 'endDecl', code: 'end'}, ' ',
        'do: ', {name: 'bodyDecl', code: 'body'}, ' {\n',
      '  ...\n',
      {name: 'theLoop', code: [
        '  ', {name: 'bodyCall', code: 'body(idx)'}, ';']}, '\n',
      '  ...\n',
      '}'
    ]},
    '\n\n',
    {name: 'gDecl', code: 'var g = 0;'}, '\n',
    {name: 'fDef', code: [
      'def f() {\n',
      '  ', {name: 'gAssignment', code: 'g = g + 1'}, ';\n',
      '}'
    ]},
    '\n\n',
    {name: 'sumDecl', code: 'var sum = 0;'}, '\n',
    {name: 'forCall', code: [
      'for 1 to: 3 do: ', {name: 'forBody', code: [
        '{', {name: 'xDecl', code: 'x'}, ' |\n',
        '  ', {name: 'sumAssignment', code: 'sum = sum + x;'}, '\n',
        '  ', {name: 'fCall', code: 'f()'}, ';\n',
        '}'
      ]}
    ]},
    ';'
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  function _for(start, end, body) {
    const forEnv = R.mkEnv(sls.forDef);
    R.declVar(sls.thisDecl, forEnv, forEnv, 'this', start);
    R.declVar(sls.endDecl, forEnv, forEnv, 'end', end);
    R.declVar(sls.bodyDecl, forEnv, forEnv, 'body', body);
    const loopEnv = R.enterScope(sls.theLoop, forEnv);
    for (let idx = start; idx <= end; idx++) {
      (R.send(sls.bodyCall, loopEnv, body, 'call', [idx]), R.receive(loopEnv, body(idx)));
    }
    R.leaveScope(loopEnv);
  }

  let g = R.declVar(sls.gDecl, globalEnv, globalEnv, 'g', 0);
  function f() {
    const fEnv = R.mkEnv(sls.fDef);
    g = R.assignVar(sls.gAssignment, fEnv, globalEnv, 'g', g + 1);
  }

  let sum = R.declVar(sls.sumDecl, globalEnv, globalEnv, 'sum', 0);
  const forBody = x => {
    const forBodyEnv = R.mkEnv(sls.forBody);
    R.declVar(sls.xDecl, forBodyEnv, globalEnv, 'x', x);
    sum = R.assignVar(sls.sumAssignment, forBodyEnv, globalEnv, 'sum', sum + x);
    (R.send(sls.fCall, forBodyEnv, f, 'call', []), R.receive(forBodyEnv, f()));
  };
  (R.send(sls.forCall, globalEnv, 1, 'for_to:do:', [3, forBody]), R.receive(globalEnv, _for(1, 3, forBody)));
});

addExample('seymour-myFor', () => {
  prog({name: 'program', code: [
    {name: 'enterDecl', code: 'var enter = 0;'}, '\n',
    {name: 'leaveDecl', code: 'var leave = 0;'}, '\n',
    {name: 'forDef', code: [
      'def for ', {name: 'thisDecl', code: 'Number'}, ' ',
        'to: ', {name: 'endDecl', code: 'end'}, ' ',
        'do: ', {name: 'bodyDecl', code: 'body'}, ' {\n',
      '  ...\n',
      {name: 'theLoop', code: [
        '  ', {name: 'enterAssignment', code: 'enter = enter + 1;'}, '\n',
        '  ', {name: 'bodyCall', code: 'body(idx)'}, ';\n',
        '  ', {name: 'leaveAssignment', code: 'leave = leave + 1;'}]}, '\n',
      '  ...\n',
      '}'
    ]},
    '\n\n',
    {name: 'gDecl', code: 'var g = 0;'}, '\n',
    {name: 'fDef', code: [
      'def f() {\n',
      '  ', {name: 'gAssignment', code: 'g = g + 1'}, ';\n',
      '}'
    ]},
    '\n\n',
    {name: 'sumDecl', code: 'var sum = 0;'}, '\n',
    {name: 'forCall', code: [
      'for 1 to: 3 do: ', {name: 'forBody', code: [
        '{', {name: 'xDecl', code: 'x'}, ' |\n',
        '  ', {name: 'sumAssignment', code: 'sum = sum + x;'}, '\n',
        '  ', {name: 'fCall', code: 'f()'}, ';\n',
        '}'
      ]}
    ]},
    ';'
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  let enter = R.declVar(sls.enterDecl, globalEnv, globalEnv, 'enter', 0);
  let leave = R.declVar(sls.leaveDecl, globalEnv, globalEnv, 'leave', 0);
  function _for(start, end, body) {
    const forEnv = R.mkEnv(sls.forDef);
    R.declVar(sls.thisDecl, forEnv, forEnv, 'this', start);
    R.declVar(sls.endDecl, forEnv, forEnv, 'end', end);
    R.declVar(sls.bodyDecl, forEnv, forEnv, 'body', body);
    const loopEnv = R.enterScope(sls.theLoop, forEnv);
    for (let idx = start; idx <= end; idx++) {
      enter = R.assignVar(sls.enterAssignment, loopEnv, globalEnv, 'enter', enter + 1);
      (R.send(sls.bodyCall, loopEnv, body, 'call', [idx]), R.receive(loopEnv, body(idx)));
      leave = R.assignVar(sls.leaveAssignment, loopEnv, globalEnv, 'leave', leave + 1);
    }
    R.leaveScope(loopEnv);
  }

  let g = R.declVar(sls.gDecl, globalEnv, globalEnv, 'g', 0);
  function f() {
    const fEnv = R.mkEnv(sls.fDef);
    g = R.assignVar(sls.gAssignment, fEnv, globalEnv, 'g', g + 1);
  }

  let sum = R.declVar(sls.sumDecl, globalEnv, globalEnv, 'sum', 0);
  const forBody = x => {
    const forBodyEnv = R.mkEnv(sls.forBody);
    R.declVar(sls.xDecl, forBodyEnv, forBodyEnv, 'x', x);
    sum = R.assignVar(sls.sumAssignment, forBodyEnv, globalEnv, 'sum', sum + x);
    (R.send(sls.fCall, forBodyEnv, f, 'call', []), R.receive(forBodyEnv, f()));
  };
  (R.send(sls.forCall, globalEnv, 1, 'for_to:do:', [3, forBody]), R.receive(globalEnv, _for(1, 3, forBody)));
});

addExample('seymour-nestedLoops', () => {
  prog({name: 'program', code: [
    {name: 'forDef', code: [
      'def for ', {name: 'thisDecl', code: 'Number'}, ' ',
        'to: ', {name: 'endDecl', code: 'end'}, ' ',
        'do: ', {name: 'bodyDecl', code: 'body'}, ' {\n',
      '  ...\n',
      {name: 'theLoop', code: [
        '  ', {name: 'bodyCall', code: 'body(idx)'}, ';']}, '\n',
      '  ...\n',
      '}']}, '\n\n',
    {name: 'countDecl', code: 'var count = 0;'}, '\n',
    {name: 'for1Call', code: [
      'for 1 to: 3 do: ', {name: 'for1Body', code: ['{', {name: 'xDecl', code: 'x'}, ' |\n',
      '  ', {name: 'for2Call', code: ['for 1 to: 3 do: ', {name: 'for2Body', code: ['{', {name: 'yDecl', code: 'y'}, ' |\n',
      '    ', {name: 'countAssignment', code: 'count = count + 1;'}, '\n',
      '  }']}]}, ';\n',
      '}']}]}, ';']});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  function _for(start, end, body) {
    const forEnv = R.mkEnv(sls.forDef);
    R.declVar(sls.thisDecl, forEnv, forEnv, 'this', start);
    R.declVar(sls.endDecl, forEnv, forEnv, 'end', end);
    R.declVar(sls.bodyDecl, forEnv, forEnv, 'body', body);
    const loopEnv = R.enterScope(sls.theLoop, forEnv);
    for (let idx = start; idx <= end; idx++) {
      (R.send(sls.bodyCall, loopEnv, body, 'call', [idx]), R.receive(loopEnv, body(idx)));
    }
    R.leaveScope(loopEnv);
  }

  let count = R.declVar(sls.countDecl, globalEnv, globalEnv, 'count', 0);
  const for1Body = x => {
    const for1BodyEnv = R.mkEnv(sls.for1Body);
    const for2Body = y => {
      const for2BodyEnv = R.mkEnv(sls.for2Body);
      R.declVar(sls.yDecl, for2BodyEnv, for2BodyEnv, 'y', y);
      count = R.assignVar(sls.countAssignment, for2BodyEnv, globalEnv, 'count', count + 1);
    };
    R.declVar(sls.xDecl, for1BodyEnv, for1BodyEnv, 'x', x);
    (R.send(sls.for2Call, for1BodyEnv, 1, 'for_to:do:', [3, for2Body]), R.receive(for1BodyEnv, _for(1, 3, for2Body)));
  };
  (R.send(sls.for1Call, globalEnv, 1, 'for_to:do:', [3, for1Body]), R.receive(globalEnv, _for(1, 3, for1Body)));
});

addExample('seymour-preEvents', () => {
  prog({name: 'program', code: [
    {name: 'forDef', code: [
      'def for ', {name: 'thisDecl', code: 'Number'}, ' ',
        'to: ', {name: 'endDecl', code: 'end'}, ' ',
        'do: ', {name: 'bodyDecl', code: 'body'}, ' {\n',
      '  ...\n', {name: 'theLoop', code: [
      '  ', {name: 'bodyCall', code: 'body(idx)'}, ';']}, '\n',
      '  ...\n',
      '}'
    ]},
    '\n\n',
    {name: 'gDecl', code: 'var g = 0;'}, '\n',
    {name: 'fDef', code: [
      'def f() {\n',
      '  ', {name: 'gAssignment', code: 'g = g + 1;'}, '\n',
      '  ', {name: 'fReturn', code: 'return g;'}, '\n',
      '}'
    ]},
    '\n\n',
    {name: 'sumDecl', code: 'var sum = 0;'}, '\n',
    {name: 'forCall', code: [
      'for ', {name: 'fCall1', code: 'f()'}, '\n',
      'to: ', {name: 'fCall2', code: 'f()'}, ' + 1\n',
      'do: ', {name: 'forBody', code: [
        '{', {name: 'xDecl', code: 'x'}, ' |\n',
        '  ', {name: 'sumAssignment', code: 'sum = sum + x;'}, '\n',
        '}'
      ]}
    ]},
    ';'
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  function _for(start, end, body) {
    const forEnv = R.mkEnv(sls.forDef);
    R.declVar(sls.thisDecl, forEnv, forEnv, 'this', start);
    R.declVar(sls.endDecl, forEnv, forEnv, 'end', end);
    R.declVar(sls.bodyDecl, forEnv, forEnv, 'body', body);
    const loopEnv = R.enterScope(sls.theLoop, forEnv);
    for (let idx = start; idx <= end; idx++) {
      (R.send(sls.bodyCall, loopEnv, body, 'call', [idx]), R.receive(loopEnv, body(idx)));
    }
    R.leaveScope(loopEnv);
  }

  let g = R.declVar(sls.gDecl, globalEnv, globalEnv, 'g', 0);
  function f() {
    const fEnv = R.mkEnv(sls.fDef);
    g = R.assignVar(sls.gAssignment, fEnv, globalEnv, 'g', g + 1);
    return R.localReturn(sls.fReturn, fEnv, g);
  }

  let sum = R.declVar(sls.sumDecl, globalEnv, globalEnv, 'sum', 0);
  const forBody = x => {
    const forBodyEnv = R.mkEnv(sls.forBody);
    R.declVar(sls.xDecl, forBodyEnv, forBodyEnv, 'x', x);
    sum = R.assignVar(sls.sumAssignment, forBodyEnv, globalEnv, 'sum', sum + x);
  };
  const start = (R.send(sls.fCall1, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
  const end = (R.send(sls.fCall2, globalEnv, f, 'call', []), R.receive(globalEnv, f())) + 1;
  (R.send(sls.forCall, globalEnv, start, 'for_to:do:', [end, forBody]), R.receive(globalEnv, _for(start, end, forBody)));
});

addExample('emptySends', () => {
  prog({name: 'program', code: [
    {name: 'xDecl', code: 'var x = 5;'}, '\n',
    {name: 'fDef', code: ['function f() { ', {name: 'fReturn', code: 'return 42;'}, '}']}, '\n\n',
    {name: 'fCall1', code: 'f()'}, ';\n\n',
    {name: 'fCall2', code: 'f()'}, '; ', {name: 'fCall3', code: 'f()'}, ';\n\n',
    {name: 'fCall4', code: 'f()'}, '; ', {name: 'fCall5', code: 'f(\n)'}, '; ', {name: 'fCall6', code: 'f()'}, ';\n\n',
    {name: 'xAssign1', code: 'x = 1;'}, '\n',
    {name: 'xAssign2', code: 'x = 2;'}, ' ', {name: 'xAssign3', code: 'x = 3;'}, '\n',
    {name: 'xAssign4', code: 'x = 4;'}, ' ', {name: 'xAssign5', code: 'x = 5;'}, ' ', {name: 'xAssign6', code: 'x = 6;'}, '\n\n',
    {name: 'xAssign7', code: ['x = ', {name: 'fCall7', code: 'f()'}, ';']}, '\n',
    {name: 'xAssign8', code: ['x = ', {name: 'fCall8', code: 'f()'}, ';']}, ' ', {name: 'fCall9', code: 'f()'}, ';\n',
    {name: 'fCall10', code: 'f()'}, '; ', {name: 'xAssign9', code: ['x = ', {name: 'fCall11', code: 'f()'}, ';']}, ' ', {name: 'fCall12', code: 'f()'}, ';\n'
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  let x = R.declVar(sls.xDecl, globalEnv, globalEnv, 'x', 5);

  function f() {
    const fEnv = R.mkEnv(sls.fDef);
    return R.localReturn(sls.fReturn, fEnv, 42);
  }

  (R.send(sls.fCall1, globalEnv, f, 'call', []), R.receive(globalEnv, f()));

  (R.send(sls.fCall2, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
  (R.send(sls.fCall3, globalEnv, f, 'call', []), R.receive(globalEnv, f()));

  (R.send(sls.fCall4, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
  (R.send(sls.fCall5, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
  (R.send(sls.fCall6, globalEnv, f, 'call', []), R.receive(globalEnv, f()));

  x = R.assignVar(sls.xAssign1, globalEnv, globalEnv, 'x', 1);

  x = R.assignVar(sls.xAssign2, globalEnv, globalEnv, 'x', 2);
  x = R.assignVar(sls.xAssign3, globalEnv, globalEnv, 'x', 3);

  x = R.assignVar(sls.xAssign4, globalEnv, globalEnv, 'x', 4);
  x = R.assignVar(sls.xAssign5, globalEnv, globalEnv, 'x', 5);
  x = R.assignVar(sls.xAssign6, globalEnv, globalEnv, 'x', 6);

  x = R.assignVar(sls.xAssign7, globalEnv, globalEnv, 'x', (R.send(sls.fCall7, globalEnv, f, 'call', []), R.receive(globalEnv, f())));
  x = R.assignVar(sls.xAssign8, globalEnv, globalEnv, 'x', (R.send(sls.fCall8, globalEnv, f, 'call', []), R.receive(globalEnv, f())));
      (R.send(sls.fCall9, globalEnv, f, 'call', []), R.receive(globalEnv, f()));

  (R.send(sls.fCall10, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
      x = R.assignVar(sls.xAssign9, globalEnv, globalEnv, 'x', (R.send(sls.fCall11, globalEnv, f, 'call', []), R.receive(globalEnv, f())));
      (R.send(sls.fCall12, globalEnv, f, 'call', []), R.receive(globalEnv, f()));
});

/*
addExample('seymour-blockCall', () => {
  prog({name: 'program', code: [
    {name: 'xDecl', code: 'var x = 0;'}, '\n',
    {name: 'ifThenCall', code: ['if true then: ', {name: 'trueBranch', code: ['{\n',
      {name: 'bAssign', code: }}}
    'for (',
      {name: 'xDecl', code: 'let x = 0;'},
      ' x <= 3; ',
      {name: 'xAssignment', code: 'x = x + 1'}, ') {\n',
    '  ', {name: 'sumAssignment', code: 'sum = sum + x;'}, '\n',
    '}'
  ]});

});
*/

addExample('js-for', () => {
  prog({name: 'program', code: [
    {name: 'sumDecl', code: 'var sum = 0;'}, '\n', {name: 'theLoop', code: [
    'for (',
      {name: 'xDecl', code: 'let x = 0;'},
      ' x <= 3; ',
      {name: 'xAssignment', code: 'x = x + 1'}, ') {\n',
    '  ', {name: 'sumAssignment', code: 'sum = sum + x;'}, '\n',
    '}']}
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  let sum = R.declVar(sls.sumDecl, globalEnv, globalEnv, 'sum', 0);
  const loopEnv = R.enterScope(sls.theLoop, globalEnv);
  for (
      let x = R.declVar(sls.xDecl, loopEnv, loopEnv, 'x', 0);
      x <= 3;
      x =  R.assignVar(sls.xAssignment, loopEnv, globalEnv, 'x', x + 1)) {
    sum = R.assignVar(sls.sumAssignment, loopEnv, globalEnv, 'sum', sum + x);
  }
  R.leaveScope(loopEnv);
});

addExample('js-fact', () => {
  prog({name: 'program', code: [
    {name: 'fDef', code: ['function f(', {name: 'nDecl', code: 'n'}, ') {\n',
    '  if (n === 0) {\n',
    '    ', {name: 'baseReturn', code: 'return 1;'}, '\n',
    '  } else {\n',
    '    ', {name: 'mDecl', code: ['let  m = ', {name: 'recFCall', code: 'f(n - 1)'}, ';']}, '\n',
    '    ', {name: 'recReturn', code: 'return n * m;'}, '\n',
    '  }\n',
    '}']},
    '\n\n',
    {name: 'ansDecl', code: ['let ans = ', {name: 'fCall', code: 'f(5)'}, ';']}
  ]});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  function f(n) {
    const fEnv = R.mkEnv(sls.fDef);
    R.declVar(sls.nDecl, fEnv, fEnv, 'n', n);
    if (n === 0) {
      return R.localReturn(sls.baseReturn, fEnv, 1);
    } else {
      let m = R.declVar(sls.mDecl, fEnv, fEnv, 'm', (R.send(sls.recFCall, fEnv, f, 'call', [n - 1]), R.receive(fEnv, f(n - 1))));
      return R.localReturn(sls.recReturn, fEnv, n * m);
    }
  }
  let ans = R.declVar(sls.ansDecl, globalEnv, globalEnv, 'ans', (R.send(sls.fCall, globalEnv, f, 'call', [5]), R.receive(globalEnv, f(5))));
});

addExample('js-reduce', () => {
  prog({name: 'program', code: [
    {name: 'reduceAssignment', code: ['Array.prototype.reduce = ',
      {name: 'reduceFn', code: [
        'function', {name: 'thisDecl', code: '('}, {name: 'fnDecl', code: 'fn'}, ', ', {name: 'zDecl', code: 'z'}, ') {\n',
        '  ', {name: 'rDecl', code: 'var r = z;'}, '\n', {name: 'theLoop', code: [
        '  for (', {name: 'idxDecl', code: 'let idx = 0;'}, ' idx < this.length; ', {name: 'idxAssignment', code: 'idx = idx + 1'}, ') {\n',
        '    ', {name: 'rAssignment', code: ['r = ', {name: 'fnCall', code: 'fn(r, this[idx])'}, ';']}, '\n',
        '  }']}, '\n',
        '  ', {name: 'reduceReturn', code: 'return r;'}, '\n',
        '}'
      ]}, ';']}, '\n\n',
    {name: 'ansDecl', code: ['var ans = ',
      {name: 'reduceCall', code: ['[1, 2, 3, 4].reduce(\n',
        '    ', {name: 'lambda', code: ['(', {name: 'xDecl', code: 'x'}, ', ', {name: 'yDecl', code: 'y'}, ') ',
          {name: 'lambdaReturn', code: '=> x + y'}]}, ',\n',
        '    0)']}, ';']}, '\n']});

  const R = new EventRecorder();
  macroViz.setEventRecorder(R);
  cm.setValue(lines.join('\n'));
  globalEnv = R.program(sls.program);
  microViz.setPaths([new PathMatcher([], globalEnv)]);
  microViz.addImplementation(globalEnv.microVizEvents);

  const oldReduce = Array.prototype.reduce;
  Array.prototype.reduce = R.assignInstVar(sls.reduceAssignment, globalEnv, Array.prototype, 'reduce', function(fn, z) {
    const reduceEnv = R.mkEnv(sls.reduceFn);
    R.declVar(sls.thisDecl, reduceEnv, reduceEnv, 'this', this);
    R.declVar(sls.fnDecl, reduceEnv, reduceEnv, 'fn', fn);
    R.declVar(sls.zDecl, reduceEnv, reduceEnv, 'z', z);
    let r = R.declVar(sls.rDecl, reduceEnv, reduceEnv, 'r', z);
    const loopEnv = R.enterScope(sls.theLoop, reduceEnv);
    for (
        let idx = R.declVar(sls.idxDecl, loopEnv, loopEnv, 'idx', 0);
        idx < this.length;
        idx = R.assignVar(sls.idxAssignment, loopEnv, reduceEnv, 'idx', idx + 1)) {
      r = R.assignVar(sls.rAssignment, loopEnv, reduceEnv, 'r', (R.send(sls.fnCall, loopEnv, fn, 'call', [r, this[idx]]), R.receive(loopEnv, fn(r, this[idx]))));
    }
    R.leaveScope(reduceEnv);
    return R.localReturn(sls.reduceReturn, reduceEnv, r);
  });
  const arr = [1, 2, 3, 4];
  const f = function(x, y) {
    const fEnv = R.mkEnv(sls.lambda);
    R.declVar(sls.xDecl, fEnv, fEnv, 'x', x);
    R.declVar(sls.yDecl, fEnv, fEnv, 'y', y);
    return R.localReturn(sls.lambdaReturn, fEnv, x + y);
  };
  let ans = R.declVar(sls.ansDecl, globalEnv, globalEnv, 'ans', (R.send(sls.reduceCall, globalEnv, arr, 'reduce', [f, 0]), R.receive(globalEnv, arr.reduce(f, 0))));
  Array.prototype.reduce = oldReduce;
});

const exampleName = window.location.search.substring(1) || Object.keys(examples)[0];
examples[exampleName]();

    </script>
  </body>
</html>
